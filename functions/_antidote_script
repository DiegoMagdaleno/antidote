#!/usr/bin/env zsh

### Generate the Zsh script for statically loading a plugin.

emulate -L zsh
setopt local_options extended_glob

# you can bundle a plugin directory, a zsh script, or a git repo
# this function scripts that out for your zshrc
local bundle=$1
local kind=${2:-zsh}
local bundlepath=$3
local bundledir initfile initfiles=() REPLY
local skipfpath=false

function __antidote_scriptout {
  local fso=$1
  local kind=$2
  if [[ $kind = fpath ]]; then
    echo "fpath+=( $fso )"
  elif [[ $kind = path ]]; then
    echo "export PATH=\"$fso:\$PATH\""
  elif [[ $kind = defer ]]; then
    echo "zsh-defer source $fso"
  else
    echo "source $fso"
  fi
}

function __antidote_err_filenotfound {
  echo >&2 "antidote: error: failed to bundle: $1: no such file or directory"
}

# if the bundle is a zsh file, we can shortcut past other logic
if [[ -f $bundle ]]; then
  __antidote_scriptout $bundle $kind
  return
fi

# set the bundledir
if [[ -d $bundle ]]; then
  bundledir=$bundle
else
  bundledir=$(_antidote_bundledir $bundle)
  [[ -d "$bundledir" ]] || { __antidote_err_filenotfound $bundledir && return 1 }
fi

# handle specified bundlepath
if [[ -n "$bundlepath" ]]; then
  if [[ -f $bundledir/$bundlepath ]]; then
    initfiles=($bundledir/$bundlepath)
    skipfpath=true
  elif [[ -d $bundledir/$bundlepath ]]; then
    bundledir=$bundledir/$bundlepath
  else
    __antidote_err_filenotfound $bundledir/$bundlepath
    return 1
  fi
fi

# detect the init file
if [[ $#initfiles -eq 0 ]] && [[ $kind != (fpath|path) ]]; then
  _antidote_initfiles $bundledir >/dev/null || return 1
  initfiles=($REPLY)
  [[ $#initfiles -ne 0 ]] || { __antidote_err_filenotfound $bundle && return 1 }
fi

# output the script
if [[ $kind = (path|fpath) ]]; then
  __antidote_scriptout $bundledir $kind
else
  [[ $skipfpath = true ]] || __antidote_scriptout $bundledir fpath
  for initfile in $initfiles; do
    __antidote_scriptout $initfile $kind
  done
fi
