#!/usr/bin/env zsh

##? antidote-bundle - clone bundle(s) and generate the static load script
##?
##? usage: antidote bundle [<bundles>...]
##?
##? args:
##?   [<bundles>...]  bundle list

setopt local_options no_notify no_monitor

local bundle
local bundlestr=$(_antidote_parsebundles $@)
local bundles=("${(@f)${bundlestr}}")
[[ $#bundles -ne 0 ]] || return 1

# loop the first time just to clone missing bundles
local giturl username reponame shortrepo cloning=()
for bundlestr in $bundles; do
  # bundlestr sets an associative array, like so:
  # typeset -A bundle=( [kind]=zsh [repo]=foo/bar )
  eval $bundlestr
  if [[ $bundle[repo] = \$* ]] || [[ $bundle[repo] = /* ]]; then
    # path bundles
    continue
  elif [[ $bundle[repo] = */* ]]; then
    # clone the requested repo bundles in the background
    giturl=$bundle[repo]
    username=${${${giturl%/*}%.git}##*/}
    reponame=${${giturl##*/}%.git}
    shortrepo=$username/$reponame
    if ! (($cloning[(Ie)$shortrepo])); then
      cloning+=($shortrepo)
      _antidote_clone $bundle[repo] $bundle[branch] &
    fi
  fi
done

# wait for cloning to complete
wait

# now loop a second time to generate the bundle load script
local prescript=() script=()
for bundlestr in $bundles; do
  # bundlestr sets an associative array, like so:
  # typeset -A bundle=( [kind]=zsh [repo]=foo/bar )
  eval $bundlestr

  # special handling for deferred bundles
  if [[ $bundle[kind] = defer ]] && [[ $#prescript -eq 0 ]]; then
    _antidote_clone romkatv/zsh-defer
    prescript=(
      "if ! (( \$+functions[zsh-defer] )); then"
      "$(_antidote_script romkatv/zsh-defer | pr -to 2)"
      "fi"
    )
  fi

  # nothing to do for clone-only bundles
  [[ $bundle[kind] != clone ]] || continue

  script+="$(_antidote_script $bundle[repo] $bundle[kind] $bundle[path])"
done

# generate bundle load script
(( ! $#prescript )) || printf "%s\n" "${prescript[@]}"
printf "%s\n" "${script[@]}"
